
# week11~12
## Prob1
- 선물 고르기
- n개의 상품의 가치 (value)와 n개의 가격표 (price tag)가 입력으로 주어진다.
- 상품에 가격표를 붙여야 하는 것인데, 가능하면 상품에 붙인 가치와 가격표의 차이의 최대 값이 되도록 최소가 되도록 해야 한다﻿. 즉, 상품의 가치에 최대한 가깝도록 가격표를 붙이고 싶다는 의미다.
- 이 일은 생각보다 어렵지 않다. 가치와 가격표를 오름차순으로 정렬한 후에 순서대로 일대일 매칭을 하면 된다 .

- n개의 상품 중에서 하나를 빼야 한다.
- 한 개의 상품을 선택해 뺀다면, n-1개의 상품과 n개의 가격표가 남는데, 최소 차이 값이 되도록 n-1개의 상품과 n개의 가격표의 매칭이 되는 상품 하나를 선택.
- 가치-가격표의 최대 차이가 최소가 되도록 상품을 하나 선택해 제거해야 한다. 이렇게 선택한 상품의 가치를 출력한다. 만약 그런 상품이 여러 개라면 그 중 가장 작은 가치를 출력한다.

### 해결 방법
- 상품을 제외하지 않을 때, 최적의 경우는 상품의 가치 리스트 values와 가격표 리스트 tags를 오름차순으로 정렬한 후 1:1 매칭을 하는 것이다.
- 그러나 이때 n개의 상품 중 1개를 제외해서 최적의 경우를 구하기 위해서는 
제외하는 상품을 기준으로 같은 위치에 존재하는 tag 또는, 그 이전 위치의 tag 값과 비교한 후 그 차이가 최소가 되는 경우를 구해주고, 자신보다 더 작은 value를 가졌던 상품들에 대해서도 같은 연산을 진행하게 된다.
- 즉, 그대로 같은 인덱스에 존재하는 value-tag 쌍을 가져갈지, 그 이전 인덱스에 위치하는 tag와 쌍을 이룰지 for문을 거쳐 dp 테이블을 구성한다(#Prob1 주석을 달아놓았습니다.).
- 그 후, 구해준 모든 경우의 수를 비교해주며 최적의 경우를 구해나간다.
- gift_prob.py , gift_prob2.py

### 수행시간
- O(nlogn)


---

## Prob2
- 땅 따먹기
- n x n 격자 판으로 구성된 큰 땅이 있다. 각 격자 칸에는 해당 칸의 땅의 가치가 적혀 있다.
- 1 x 3 타일 k개 준비되어 있다. 여러 분은 이 타일을 겹치지 않도록 모두 사용해서 n x n 격자 칸에 놓으면, 놓인 칸의 땅을 모두 얻을 수 있다.
- 이왕이면, 가치가 최대가 되도록 타일을 놓고 싶다. 가치의 최대 합을 출력하면 된다. 만약, k개의 타일을 겹치지 않고 놓을 수 없다면 -1을 출력해야 한다.

- 1 x 3 타일을 겹치지 않게 k개를 모두 놓았을 때, 타일이 놓이는 격자 칸의 가치의 합을 출력.
- 주의 1: 1 x 3 타일은 세로 1칸 x 가로 3칸으로 구성된 타일이며, 반드시 이 모양으로만 놓아야 한다 (3 x 1 타일로 사용할 수 없다!)
- 주의 2: 타일은 두 행 이상에 걸쳐 있을 수 없다. 


### 해결 방법
- i는 행에서의 특정 열의 위치, j는 열에서의 특정 행의 위치, k는 타일의 수 
- 각 행에 대해, 각 열에 대해,각 칸을 DP로 따진다. 
- j <= 2라는 것은 타일을 둘 수 없는 i번째 행에서의 특정 열 위치이며 값을 업데이트 해준다.
- else : 해당 i,j,k는  타일을 두고 k-1개의 타일을 두었을 때의 값과 해당 위치 DP[i][j-3][k-1]과 타일을 두는 위치의 합과, j-1번째 열까지 진행을 하고 k개의 타일을 두었을 때의 max로 업데이트 
- 1x3_tiling_prob.py

### 수행시간
- O(n^2 * k)


---



