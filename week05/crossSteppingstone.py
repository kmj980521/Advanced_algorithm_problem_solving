# -*- coding: utf-8 -*-
# UTF-8 encoding when using korean

L, n, k = map(int,input().split())
A = list(map(int,input().split()))

A.append(L)

def search(A,start,end,k):
	value = 0
	if len(A)-1 == k: # 최대로 뺄 수 있는 돌의 수 k가 n과 같다면 반드시 강의 폭이 정답 
		return L
	while start<=end:
		mid = (start + end) //2 
		count = 0 # 걸러지는 돌의 수 
		now = 0 
		for i in range(len(A)-1):  
			if mid > A[i]: # mid 최대로 점프할 수 있는 거리보다 작은 돌들은 걸러낸다 
				count+=1
			else: 
				now = i # 같거나 큰 값이 오면 현재 자기 위치에 멈추고 다르게 판별한다. 
				break
		for j in range(now+1, len(A)):
			if A[j] - A[now] < mid: # 자신이 서있는 지점과 새로 판별하려는 지점 사이의 거리를 따져 mid 보다 작다면 돌을 걸러낸다. 
				count+=1
			else: # 만약 자신이 서있는 지점과 새로 판별하려는 지점 사이의 거리가 mid 보다 크다면 냅두고 자신을 새로 옮긴다 
				now = j
		if count > k: # 돌을 기준보다 더 많이 걸러냈으므로 더 작은 mid 값에서 판별하기 위해 end를 조정 
			end = mid-1
		else: # 돌을 기준보다 덜 걸러냈으므로 더 큰 mid 값에서 판별하기 위해 start를 조정 
			start = mid +1
		value = end

	return value

print(search(A,0,L,k))

"""
해결 과정
1. 강의 폭 L, 돌의 수 n, 뺄 수 있는 돌의 최대 개수 k를 입력 받는다.
2. 징검다리를 건너기 위해 필요한 점프 값이 최대가 되려면 돌을 전부 다 빼서 L만큼 점프를 하거나, 그렇지 않은 경우에는 강의 폭 중앙에서 점프를 뛰는 것이 가장 커진다. 만약 최대로 뺄 수 있는 돌의 개수가 n과 같다면 굳이 판별할 필요 없이 당연히 폭의 거리가 답이 될 것이다. 그리고 이 경우가 아닌 강의 폭 중앙에서 점프를 뛰는 것이 가장 값이 큰 이유는 k가 n일 때를 제외하고 만약 돌이 1개를 남기고 모두 제외 및 L이 20이라고 가정했을 때 17위치에 돌이 있다면 처음에서 돌로 가는 거리는 17이지만, 끝으로 가는 점프 값인 3으로도 가능하다. 즉 이를 반복하다 보면 폭의 중앙에 위치한 돌에서 점프를 하는 것이 가장 큰 값인 것을 확인할 수 있고, 이를 이용할 것이다. 
3. 또한, 돌을 점프 값이 최대일 때를 판별하기 위해 최대 점프 값(mid)을 받았을 때 처음부터 그 값보다 더 작은 위치에 존재하는 돌들(절대 최대가 될 수 없다)을 제외하고 count를 증가시킨다. 중앙값과 비슷한 위치에 존재하는 돌(now돌)을 찾으면 우선 멈추고 이 돌의 위치가 현재 나의 위치라고 본다. 그 후 now돌을 기준으로 다음 돌들을 찾아가며 돌 사이의 간격이 최대 점프 값인 mid보다 작다면 돌을 제외시키고 now돌은 그 자리에 유지시키고, 판별한 돌 다음 돌의 거리값을 계산하고 만약 mid 값보다 크거나 같다면 자기가 위치하는 now의 값을 업데이트 한다. 즉, 돌들을 걸러내며 그때그때 달라지는 mid 값보다 크거나 같은 값이 오게끔 돌을 골라내는 과정을 거친다. 
4. 그 후 걸러낸 돌의 수 count가 k보다 크다면 현재 판별하고 있는 mid 값이 커서 많은 돌들이 걸러진다는 의미이기 때문에 더 작은 값에서 위의 과정을 거치기 위해 end를 mid - 1로 조정한다. 만약 count가 k보다 작다면 현재 판별하고 있는 mid 값이 작기 때문에 돌을 원하는 만큼 골라내지 못한다는 의미이기 때문에 더 큰 값에서 위의 과정을 거치기 위해 start를 mid + 1로 조정한다.
5. 또한, return 값은 범위를 줄여나가며 찾다가 end값이 최대 거리이기 때문에 value라는 변수에 end를 업데이트 시켜준다. 
6. 이와 같은 과정을 거쳐, 최대로 점프할 수 있는 돌의 위치를 이진탐색을 활용해 찾아가고, while이 끝나면 value 값 즉, 최대로 점프할 수 있는 거리를 반환한다.

"""

"""
수행시간 분석 
1. 강의 폭 L, 돌의 수 n, 뺄 수 있는 돌의 최대 개수 k, 강의 폭 L을 A 리스트에 append 하는 시간은 상수 시간 O(1)
2. 입력받은 값을 리스트로 반환하는 데에 O(n)
3. start와 end로 mid 값을 구하고 특정 기준에 맞게 반씩 줄여나가는 방식이기 때문에 while 문의 수행 시간은 O(logn)
4. mid 값보다 작은 돌을 걸러내는 첫 for문과 그 이후 돌들을 새로 걸러내는 for문은 합쳤을 때 모든 돌을 끝까지 탐색하기 때문에 2개의 for문을 합쳐야 O(n)
5. 결국엔 O(n)의 수행시간이 걸리는 코드가 logL번 수행되기 때문에 O(nlogL)의 수행시간을 가질 것이다.
6. 수행시간 : O(nlogL)
"""

