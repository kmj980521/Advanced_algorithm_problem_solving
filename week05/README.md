
# week5
## Prob1
- 어긋난 리스트
- 리스트 A의 값을 오름차순으로 정렬한 후, 실수로 왼쪽 방향으로 rotation 이동을 했을 때 얼마나 이동했는지 찾아내기
- 비교 연산의 횟수를 최대한 줄이는 것을 목표로 한다


### 예시
- A [5, 8, 9, 15, 18, 20, 31]
- 왼쪽으로 3번 회전을 했을 때 A [15, 18, 20, 31, 5, 8, 9]가 된다


### 해결 방법
- 리스트 처음부터 시작하는 start, 끝부터 시작하는 end를 두었다. 
- 양 끝에서 서로 출발하고 A[start] < A[end] 즉, A[start]는 값을 커지며 가다가, A[end]는 값이 작아지며 가다가 A[start]가 더 작아지는 순간은 그만큼 rotation을 판별할 위치이다.
- 만약 start가 0이라면 즉, 맨 처음과 맨 끝을 비교했는데 바로 while을 빠져나왔다면 올바르게 오름차순이 된 것으로 보아 0을 반환한다. ( A = [1, 3, 5, 6, 7, 9]인 경우이다.)
- 만약 A[start] < A[start-1] 즉, A = [5, 6, 1, 2, 3, 4]와 같은 경우에서 start는 2의 값을 갖고 end는 3의 값을 가져 while을 빠져 나오고 이때는 start 위치를 비교해 자기 이전 값과 비교했을 때 이전 값이 더 크다면 리스트 전체 길이 - 현재 자기 위치(2)를 한 4가 나오게 되며 이는 왼쪽으로 rotation 한 횟수이다.
- 만약 A[end] > A[end+1] 즉, A = [ 3, 4, 5, 6, 1, 2] end가 멈춘 지점은 [3]인데 그 다음 값과 비교하여 더 작다면 리스트 전체 길이 - (현재 자기 위치 +1(4))를 한 2가 나오게 되며 이는 왼쪽으로 rotation 한 횟수이다. 
- listRotation.py


### 수행시간
- O(n)


---

## Prob2
- 샛강 건너기
- 폭이 L인 강에 n개의 돌로 구성된 징검다리가 있을 때 최대 k개의 돌을 뺐을 때 최대 점프 값을 출력

### 예시
- L = 12, n = 4, k = 1, S = [2, 4, 5, 8] 
- 돌을 빼지 않는다면 1만큼 점프가 필요하다
- 위치 2의 돌을 빼면 [4, 5, 8] 세 개의 돌만 남고 역시 최소 1 이상의 점프가 필요하다
- 위치 4의 돌을 빼면 [2, 5, 8] 세 개의 돌만 남고 최소 2 이상의 점프(위치 0에서 첫 돌의 위치 2까지의 점프)가 필요하다
- 위치 5의 돌을 빼면 [2, 4, 8]이 되고 최소 2 이상의 점프가 필요하다 
- 위치 8의 돌을 빼면 [2, 4, 5]이 되고 최소 1 이상의 점프가 필요하다 
- 4가지 경우 중 필요한 점프 값이 가장 큰 경우는 위치 4, 5중 하나의 돌을 빼서 최소 2 이상의 점프가 필요한 경우가 된다

### 해결 방법
- 강의 폭 L, 돌의 수 n, 뺄 수 있는 돌의 최대 개수 k를 입력 받는다.
- 징검다리를 건너기 위해 필요한 점프 값이 최대가 되려면 돌을 전부 다 빼서 L만큼 점프를 하거나, 그렇지 않은 경우에는 강의 폭 중앙에서 점프를 뛰는 것이 가장 커진다. 만약 최대로 뺄 수 있는 돌의 개수가 n과 같다면 굳이 판별할 필요 없이 당연히 폭의 거리가 답이 될 것이다. 그리고 이 경우가 아닌 강의 폭 중앙에서 점프를 뛰는 것이 가장 값이 큰 이유는 k가 n일 때를 제외하고 만약 돌이 1개를 남기고 모두 제외 및 L이 20이라고 가정했을 때 17위치에 돌이 있다면 처음에서 돌로 가는 거리는 17이지만, 끝으로 가는 점프 값인 3으로도 가능하다. 즉 이를 반복하다 보면 폭의 중앙에 위치한 돌에서 점프를 하는 것이 가장 큰 값인 것을 확인할 수 있고, 이를 이용할 것이다. 
- 또한, 돌을 점프 값이 최대일 때를 판별하기 위해 최대 점프 값(mid)을 받았을 때 처음부터 그 값보다 더 작은 위치에 존재하는 돌들(절대 최대가 될 수 없다)을 제외하고 count를 증가시킨다. 중앙값과 비슷한 위치에 존재하는 돌(now돌)을 찾으면 우선 멈추고 이 돌의 위치가 현재 나의 위치라고 본다. 그 후 now돌을 기준으로 다음 돌들을 찾아가며 돌 사이의 간격이 최대 점프 값인 mid보다 작다면 돌을 제외시키고 now돌은 그 자리에 유지시키고, 판별한 돌 다음 돌의 거리값을 계산하고 만약 mid 값보다 크거나 같다면 자기가 위치하는 now의 값을 업데이트 한다. 즉, 돌들을 걸러내며 그때그때 달라지는 mid 값보다 크거나 같은 값이 오게끔 돌을 골라내는 과정을 거친다. 
- 그 후 걸러낸 돌의 수 count가 k보다 크다면 현재 판별하고 있는 mid 값이 커서 많은 돌들이 걸러진다는 의미이기 때문에 더 작은 값에서 위의 과정을 거치기 위해 end를 mid - 1로 조정한다. 만약 count가 k보다 작다면 현재 판별하고 있는 mid 값이 작기 때문에 돌을 원하는 만큼 골라내지 못한다는 의미이기 때문에 더 큰 값에서 위의 과정을 거치기 위해 start를 mid + 1로 조정한다.
- 또한, return 값은 범위를 줄여나가며 찾다가 end값이 최대 거리이기 때문에 value라는 변수에 end를 업데이트 시켜준다. 
- 이와 같은 과정을 거쳐, 최대로 점프할 수 있는 돌의 위치를 이진탐색을 활용해 찾아가고, while이 끝나면 value 값 즉, 최대로 점프할 수 있는 거리를 반환한다.
- crossSteppingstone.py

### 수행시간
- O(nlogn)




