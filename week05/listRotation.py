
def search(A,start,end):
	while start<end: # start와 end가 교차하면 멈춘다. 양 옆에서 포인터가 이동하면서 찾음 
		if A[start] < A[end]: # start 왼쪽 값이 더 작은 값이 온다면 그 위치에서 오름차순이 제대로 수행된다는 것 
			break
		start += 1
		end -= 1
	if start == 0 : # start가 0 즉, 처음에 멈춰버리면 아예 회전조차 안한 것이다 
		return 0 
	if A[start] < A[start-1]: # 멈춘 지점에서 start가 이전 값 즉, 자기 왼쪽 값과 비교했을 때 더 작다면 해당 위치까지 rotation된 것 
		return len(A)-start 
	elif A[end] > A[end+1]: # 멈춘 지점에서 end가 그 다음 값 즉, 자기 오른쪽 값과 비교했을 때 더 크다면 해당 위치까지 rotation된 것. 오른쪽 값이 더 작으니 해당 위치 이전까지 1번 덜 rotate 했다는 의미로 -1
		return len(A) - (end+ 1)
	
A = list(map(int,input().split()))
print(search(A,0,len(A)-1))




"""
해결 과정
0. 리스트 처음부터 시작하는 start, 끝부터 시작하는 end를 두었다. 
1. 양 끝에서 서로 출발하고 A[start] < A[end] 즉, A[start]는 값을 커지며 가다가, A[end]는 값이 작아지며 가다가 A[start]가 더 작아지는 순간은 그만큼 rotation을 판별할 위치이다.
2. 만약 start가 0이라면 즉, 맨 처음과 맨 끝을 비교했는데 바로 while을 빠져나왔다면 올바르게 오름차순이 된 것으로 보아 0을 반환한다. ( A = [1, 3, 5, 6, 7, 9]인 경우이다.)
3. 만약 A[start] < A[start-1] 즉, A = [5, 6, 1, 2, 3, 4]와 같은 경우에서 start는 2의 값을 갖고 end는 3의 값을 가져 while을 빠져 나오고 이때는 start 위치를 비교해 자기 이전 값과 비교했을 때 이전 값이 더 크다면 리스트 전체 길이 - 현재 자기 위치(2)를 한 4가 나오게 되며 이는 왼쪽으로 rotation 한 횟수이다.
4. 만약 A[end] > A[end+1] 즉, A = [ 3, 4, 5, 6, 1, 2] end가 멈춘 지점은 [3]인데 그 다음 값과 비교하여 더 작다면 리스트 전체 길이 - (현재 자기 위치 +1(4))를 한 2가 나오게 되며 이는 왼쪽으로 rotation 한 횟수이다. 
"""
"""
수행시간 분석
1. start 및 end 변수 선언을 하는 시간 상수 시간 O(1)
2. start는 리스터 처음부터, end는 리스트 끝부터 서로 진행을 하고, 서로 교차되는 순간 즉, 최대의 경우에는 len(A) / 2 지점에서 만나게 되며 이는 총 n / 2 번의 비교가 일어난 것이다.
3. 비교를 하는 시간 및 start와 end를 이동하는 시간은 상수 시간 O(1)이지만 이 횟수가 최대 O(n/2)만큼 수행되기 때문에 start와 end를 적절한 위치로 판별하는 시간은 O(n)시간이 걸릴 것이다.
4. 그 후 if문으로 값을 반환하는 과정은 상수 시간 O(1)에 가능하게 된다.
5. 위의 모든 경우를 합쳤을 때 O(n) + 2O(1) 시간이 걸리게 되며 최종적으로는 O(n) 수행시간이 걸릴 것이다.
"""

