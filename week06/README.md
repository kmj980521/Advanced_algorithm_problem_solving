
# week6
## Prob1
- 좀비, 좀비, 좀비 ... 
- 좀비 n마리가 직선으로 된 산 길에 일렬로 서 있고, 각 좀비가 마주치면 방향을 바꿔 이동하고, 양 끝에서 더 가게 되면 떨어지게 된다. 이때 k번째로 떨어지는 좀비의 id 값을 구한다.
- 각 좀비에 대해 초기 위히와 처음 이동 방향이 주어진다
  - 좀비의 아이디는 0이 아닌 -n부터 n까지의 서로 다른 정수이다
  -  초기 위치는 정수 좌표로 주어지며 좀비의 위치는 서로 다르다
  -  왼쪽 방향은 -, 오른쪽 방향은 + 의미이여 이를 좀비의 아이디 값고 ㅏ함께 표시한다. 예를 들어 아이디가 -2라면 2번 좀비의 처음 이동 방향은 왼쪽이라는 의미이다

![image](https://user-images.githubusercontent.com/61898890/161786628-6efc8886-2ca5-426e-a156-68c31c27de8a.png)

  - 모든 좀비는 초기 위치에서 처음에 움직일 방향으로 일정한 속력 (1거리단위/1초) 으로 움직인다. 도중에 두 좀비가 만날 수 있다. 이 경우에는 각자 움직이는 방향과 반대 방향으로 돌아서 계속 움직인다
  - 단, 만나서 방향을 반대로 바꾸기 위한 시간은 0이라고 가정한다
  - 길의 양 쪽 끝에 도달해서 더 진행하면 절벽으로 바로 떨어지게 된다  (만약, 두 좀비가 양쪽 끝에서 동시에 같은 시간에 떨어진다면 (부호를 포함한) 아이디가 더 작은 좀비가 더 먼저 떨어지는 것으로 가정한다)
  
  
### 예시
```python
6 30 3
5 4
8 5
19 -1
22 -3
24 -2
25 6

```
- 출력

```python
-2
```
### 해결 방법
- 기본적인 알고리즘은 좀비에게 특정 이벤트(좀비가 왼쪽으로 떨어지거나, 오른쪽으로 떨어지거나, 또는 두 좀비가 만나 방향을 바꾸게 되는 이벤트가 일어난다거나)가 일어날 때까지의 최소 시간 min_time을 구해 1초마다 for를 돌리는 것이 아닌, 한 번에 좀비들을 이동시켜주는 방식이다. 또한, 좀비들이 짝을 이룰 때 (+ 방향으로 가는 좀비가 있다면 반드시 그 다음에 - 방향으로 가는 좀비가 있어야 충돌이 일어난다)를 이용할 것이다. 
- 처음엔 좀비의 위치와 id를 입력 받고 그 id에 맞는 방향(direct) 값도 저장한다.
- 큰 while 문에서는 outZombies(떨어져나간 좀비의 id를 저장하는 리스트)의 길이가 k와 같아질 때 종료를 하게 한다. 또한, 현재 판별 상태를 저장하기 위해 prev라는 변수를 선언했다. 
- zombies Deque에 저장된 좀비들의 위치를 보며 min_time을 구해준다.
  -  짝을 이룬 상태인 prev에 값이 없는 상태 즉, 이전에 충돌 및 왼쪽으로 가는 좀비들을 봐온 상태에서 좀비의 방향이 -1 이라면? -> 왼쪽 끝으로 떨어진다고 생각하고 그 거리를 구해 현재 min_time보다 작다면 업데이트 한다.
  -  짝을 이룬 상태인 prev에 값이 없는 상태에서 좀비의 방향이 +1 이라면? -> 오른쪽 끝으로 떨어진다고 생각하고 그 거리를 구해 현재 min_time보다 작다면 업데이트를 하고 prev를 +로 바꿔준다.
  -  prev의 값이 +인 상태 즉, 판별할 좀비의 이전 좀비가 오른쪽으로 이동하고 있는 좀비일 때, 현재 좀비의 방향이 -1 이라면? -> 서로 충돌할 가능성을 고려한다. 두 좀비 사이의 거리 //2의 값이 현재 min_time보다 작다면 업데이트 한다. 
      -  만약 min_time이 0이고, 두 좀비 사이의 거리가 1일 때 즉, 예를 들어 12 위치에 + 방향으로 이동하는 좀비가 있고, 13 위치에 - 방향으로 이동하는 좀비가 있다면 우선 서로 1칸씩 그대로 이동하고 추후에 방향을 바꿔 1칸씩 이동하면 자기 원래 위치에서 방향을 바꾼 것과 같게 되므로 우선 그대로 1칸 더 이동을 한 후에 방향을 바꿔준다. 
      -  만약 min_time이 0이고, 두 좀비 사이의 거리가 0일 때 즉, 예를 들어 13 위치에 + 방향으로 이동하는 좀비, 13 위치에 - 방향으로 이동하는 좀비가 겹쳐져 있다면, 서로 방향을 바꿔준다. 
  - prev 값이 +인 상태 즉, 판별할 좀비의 이전 좀비가 오른쪽으로 이동하고 있는 좀비일 때, 현재 좀비의 방향이 +1 이라면? -> 서로 같이 오른쪽으로 가서 떨어진다고 생각하고 현재 좀비가 떨어지는 시간을 구해 min_time보다 작다면 업데이트한다. 
- 이후 this_time_out_zombies_count라는 변수를 두며 모든 좀비에 대해 판별이 끝난 후 좀비를 이동시킬 때 양 옆으로 떨어지는 좀비의 수를 count할 변수를 선언한다. 
- 현재 남아있는 zombie의 수만큼 while을 돌 것이고, min_time이 0일 때, 즉 위에서 좀비의 방향이 교차할 때 사실은 1 타임이 소요되고 이동을 해야하기 때문에 min_time은 1로 설정한다.
- 특정 이벤트가 일어나는 시간인 min_time과 각 좀비의 방향을 곱해 현재 좀비 위치에 더해준다면 소요시간만큼 좀비가 이동한 것이다. 
- 좀비가 만약 0보다 작은 값 즉, 왼쪽으로 떨어지거나 L 보다 큰 값 즉, 오른쪽으로 떨어진다면 this_time_out_zombies_count 변수에 1을 더하고, 이 좀비의 id를 outZombies에 append 한다. 
- 만약 좀비가 왼쪽으로 떨어졌다면 popleft()를 하고 popleft를 하면 자동으로 다음 좀비가 0번째 좀비가 되므로 이 좀비를 다음 loop에서 판별해주기 위해 i의 값을 1 감소시킨다.
- 만약 좀비가 오른쪽으로 떨어졌다면 pop()을 해준다.
- 만약 이번 loop 에 떨어진 좀비의 수가 2라면? -> 맨 뒤 좀비와 그 앞의 좀비의 id를 비교해 더 작은 좀비가 먼저 떨어진 것으로 하기 위해 swap을 해준다. 
- zombie!zombie!.py


### 수행시간
- O(n^3)






