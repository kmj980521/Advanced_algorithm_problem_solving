
# week4
## Prob1
- 특정 조건에 만족하는 세 개의 값 a, b, c 찾기
- n개의 정수 값을 입력받아 아래의 조건을 만족하는 순서쌍 찾기

![image](https://user-images.githubusercontent.com/61898890/159154015-0764ecde-1c4a-4762-a9e3-cc10d1054cec.png)

### 예시
- A [8, 3, 1, 5, 6]
- (1, 3, 5)는 조건을 모두 만족
- (1, 3, 6)도 조건을 모두 만족
- (1, 5, 6)은 두 번째 조건을 만족하지 못함 
- (1, 3, 8) 역시 두 번째 조건을 만족하지 못함
- 이와 같은 경우 (1, 3, 5), (1, 3, 6), (3, 5, 8), (5, 6, 8) 네 가지가 나온다

### 해결 방법
- 0. 리스트를 사용했고, 이를 오름차순으로 정렬한 후(1번 조건 만족을 위해) a,b 순서쌍을 먼저 선택한 후 c 값의 범위를(2번 조건을 전개해서) c보다 작거나 같은 값이 가능한 인덱스는 upper bound, c보다 크거나 같은 값이 가능한 인덱스는 lower bound로 찾아내 사이에 몇 개의 수가 가능한지 구해 O(n^2logn)에 구현했다.


- 1. n개의 숫자를 입력받아 A 리스트를 선언하고, 1번 조건인 a < b < c를 만족하기 위해 A를 오름차순으로 sorting 해주었다.


- 2. 2번 조건을 전개 하면 모든 항에 b를 더했을 때 '2b-a <= c <= 3b-2a' 라는 수식이 나온다. 이를 이용해 a는 A리스트의 0번째부터, b는 a위치 +1번째로 시작하며 순서쌍을 구해주고 a와 b가 결정이 됐다면 2b-a 값은 left_target, 3b-2a 값은 right_target으로 둔다.


- 3. j번째 숫자 다음부터 c값을 결정하기 때문에 k라는 변수에 j+1을 삽입한다.


- 4. 정렬 된 배열에서 정렬 된 순서를 유지하며 left_target을 삽입한다고 가정했을 때 가능한 위치 즉, left_target의 값보다 크거나 같은 값이 처음으로 나오는 위치를 이진 탐색으로 찾기 위해 bisect_left를 사용했고 반환값을 left_idx에 저장한다. -> (A 리스트에 대해, left_target을 삽입한다고 가정했을 때, low는 k 값 인덱스부터, high는 A의 리스트 길이 인덱스까지 가능한 값을 구한다)


- 5. 마찬가지로 right_target을 삽입한다고 가정했을 때 가능한 위치 즉, 이번에는 right_target의 값보다 작거나 같은 값이 처음으로 나오는 위치를 이진 탐색으로 찾기 위해 bisect_right를 사용했고 반환값을 right_idx에 저장한다.


- 6. 두 과정을 거치면 left_idx부터 right_idx 사이에는 2번 조건을 만족하는 c값들이 존재할 것이고, right_idx 값에서 left_idx를 빼주면 해당 인덱스값들 사이에 A 리스트에서 2번 조건에 부합되는 c 값이 되는 원소의 숫자들이 나오기 때문에 이 값을 count에 저장한다. 


- searchABC.py

### 수행시간
-  O(n^2logn)


---

## Prob2
- 시장 선거 


- n명의 시민이 시장 선거를 했고, 시민이 선택한 후보의 번호를 리스트 A에 저장한다 (단, n은 1이상 100,000이하의 정수)
- 시장 당선 규칙은 투표 시민의 반보다 많은 지지를 받아야 하고 그런 후보가 없다면 선거를 다시 실시해야 한다 
- 만약 시장 당선자가 있다면 그 후보자 번호를 출력하고, 없다면 -1을 출력한다 

### 예시
- A = [1, 4, 1, 2, 1]이라면, 전체 5명의 후보중에서 1번이 3표로 5/2 = 2.5표보다 많기에 선출이 된다
- 그러나 A = [1, 3, 1, 2]라면, 1번이 2표를 받았지만 4/2 = 2표를 넘지 않기 때문에 1번은 당선자가 아니다

### 해결 방법
- 0. 딕셔너리를 사용해 메모리를 효율적으로 관리하고 특정 후보자가 몇 표를 받았는지 빠르게 정보를 알 수 있게 했다.
- 1. 시장 후보의 정보를 저장하기 위한 mydict 딕셔너리를 선언했고 (key-value) 쌍은 (후보 번호-득표수)로 관리할 것이다. 
- 2. A 리스트를 돌며 특정 후보자의 번호를 하나씩 받아오고 이 번호가 키 값으로 존재하지 않는다면 새로운 1표를 받았다는 의미로 mydict에 새로 삽입한다.
- 3. 만약 mydict에 존재한다면 value 값을 얻고, value 값에 +1을 해준다.
- 4. 그 후 mydict에서 (key-value) 쌍으로 이루어진 투플들이 담긴 리스트를 dict_lis에 반환받는다.
- 5. 리스트를 순환하며 person[1] (value=득표수)가 n/2 즉, 과반수 초과라면 해당 시장 후보의 번호(person[0])를 당선인 후보 번호(electedPersonIdx)에 저장하고 마지막에 출력한다.


- electionProblem.py

### 수행시간
-  O(n)


---

## Prob3
- 두 여왕
- n * n 체스 보드에 2개의 여왕(queen)을 놓고 싶을 때 놓을 수 있는 방법이 몇 가지인지 계산하기 
- 단, 두 여왕은 같은 행, 같은 열, 같은 대각선 위에 놓이면 안 된다.

### 예시
- n = 3 
-  3 x 3 체스 보드에 놓을 수 있는 두 여왕의 위치 쌍의 개수는 8개이다 (아래 그림 참조)

![image](https://user-images.githubusercontent.com/61898890/159154164-2972a46c-84f8-4480-834f-041897f3cf64.png)


### 해결 방법
- 0. 2차원 리스트를 사용했고, 첫 번째 Queen([row][col]위치)를 특정 위치에 두고 다른 Queen이 위치할 수 있는 경우의 수가 얼마나 되는지 판별한다. 


- 1. 이때 첫 번째 Queen은 0,0부터 시작하고 (0,1) (0,2) ... (0,n-1) 이렇게 column을 탐색하고 다음 row로 내려가는 방식이다. 또한, 첫 번째 Queen을 위치한다면 두 번째 Queen은 반드시 첫 번째 Queen이 거쳐온 자리는 체크하지 않는다. (왜냐하면 가능한 위치에서 Queen 서로 바꿔서 해도 같은 경우이기 때문. 불필요하게 2번 연산하는 것을 막는다.)


- 2. 입력받은 n을 이용해 n x n 2차원 리스트를 선언한다.


- 3. twoQueens() 메서드에서는 모든 row에 대해, 모든 column에 대해 가능한 경우를 모두 구해줄 것이다.


- 4. 첫 번째 Queen이 특정 위치에 있을 때 다른 Queen을 둘 수 있는 경우(possible_case)는 n*n의 공간에서 -1(첫 번째 Queen이 위치한 곳) 에서 길이가 n인 몇 개의 row를 거쳐왔는지 (row*n)를 빼주고 마지막으로 특정 row에 대해 column을 순차적으로 판별하기 때문에 지금까지 이동해 온 column의 값을 빼주면 첫 번째 Queen이 특정 [row][col]일 때 다른 Queen이 가능한 경우를 체크할 수 있다. 


- 5. 이 possible_case에서 4가지 경우를 생각해볼 수 있다. 1)첫 Queen과 같은 row에 존재하는 경우를 제외한다. 2)첫 Queen과 같은 column에 존재하는 경우를 제외한다. 3)첫 Queen과 같은 left_diagonal(왼쪽 대각선)에 존재하는 경우를 제외한다. 4)첫 Queen과 같은 right_diagonal(오른쪽 대각선)에 존재하는 경우를 제외한다.


- 5. 1) 첫 Queen과 같은 row에 존재하는 경우) row는 그대로고 오른쪽으로 가며 남은 column의 수를 센다. 최종 길이는 n-1인데 여기서 현재 첫 번째 Queen의 column 위치인 col을 빼준다.


- 5-2) 첫 Queen과 같은 column에 존재하는 경우) column은 그대로고 밑으로 가며 남은 row의 수를 센다. 최종 길이는 n-1인데 여기서 현재 첫 번째 Queen의 row 위치인 row 값을 빼준다.


- 5-3) 첫 Queen과 같은 왼쪽대각선에 존재하는 경우) 왼쪽 대각선은 column 값은 감소하지만 row 값은 증가한다. 또한 첫 번째 Queen을 기준으로 (왼쪽으로 이동 가능한 거리 x 밑으로 이동 가능한 거리)를 계산했을 때 새로운 사각형이 만들어지는 것을 알 수 있다. 첫 번째 Queen의 col의 위치에서 봤을 때 Queen이 이동한만큼이 왼쪽으로 갈 수 있는 경우이다.(왜냐하면 col은 0부터 시작을 했고, 첫 번째 Queen이 2로 이동했다면 0,1해서 2이기 때문) 또한, 첫 번째 Queen의 row의 위치에서 봤을 때 Queen이 아래로 이동할 수 있는 경우는 n-1(최종 길이)에서 현재 row 위치 값인 row를 빼준다. 


이때 첫 번째 Queen의 왼쪽으로 이동 가능한 경우를 possible_left, 아래로 이동 가능한 경우를 possible_down 변수에 값을 저장하고, 대각선은 더 작은 값을 가진만큼만 이동이 가능하기 때문에 둘 중 더 작은 값을 반환해 가능한 경우에서 빼준다.


- 5-4) 첫 Queen과 같은 오른쪽대각선에 존재하는 경우) 오른쪽 대각선은 column 값도 증가하고 row 값도 증가한다. 4-3과 다른 점은 첫 번째 Queen을 기준으로 오른쪽으로 이동 가능한 거리를 구하는 것이기 때문에 전체 길이(n-1)에서 현재 첫 번째 Queen 위치한 column인 col을 빼준다. 첫 번째 Queen을 기준으로 밑으로 이동 가능한 거리는 5-3에서 구한 것과 마찬가지이며 이 또한 대각선을 구하는 것이기 때문에, 더 작은 값을 반환해 가능한 경우에서 빼준다.


- 6. 이와 같은 과정을 모든 row에 각각의 column에 대해 값을 구하고 첫 번째 Queen이 특정 [row][col]일 때를 기준으로 나머지 Queen이 올 수 있는 경우의 수를 count 변수에 더해간다.
- twoQueens.py

### 수행시간
-  O(n^2)



