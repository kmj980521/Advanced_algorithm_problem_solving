
# week10
## Prob1
- 쌍 무지개
- 연속된 구간의 점으로 구성된 부분 집합 P'를 고려하고, P의 점들에 대해, 1번부터 k번 색이 최소 한 번 이상 등장하면 P'를 무지개(rainbow)라 부른다.
- P-P' (P'에 속하지 않는 점들의 집합) 역시 1번부터 k번 색이 최소 한 번 이상 등장하면 P-P' 역시 무지개가 된다.
- P'과 P-P' 모두 무지개라면 이를 쌍 무지개라고 부른다.
- 여러 쌍 무지개들 중에서 |P'|이 제일 작은 쌍 무지개를 찾아 출력한다.


### 해결 방법
- 기본적인 알고리즘은 start와 end 포인터 즉, 투포인터 기법을 이용해 p rainbow의 범위값을 늘리고 줄이면서 중복되지 않은 값들이 몇 개가 되는지, 동시에 이 구간을 제외한 p' rainbow도 중복되지 않은 값들이 몇 개가 되는지 판별해 나가며 p rainbow와 p' rainbow와 입력한 k와 같다면 즉, 쌍 rainbow인지 판별하고, 구간이 최소가 되는 경우를 계속 찾아나간다.
- 점의 수 n과 색의 수 k를 입력을 받고 k를 이용해 p rainbow와 p' rainbow(outer_rainbow_count) 리스트를 만든다. 각각의 인덱스가 의미하는 바는 특정 색이 특정 구간에 얼마나 저장되어 있는지를 의미한다. 
- 그 후 n만큼 for를 돌며 색을 입력을 받는데 이때, 이 색(point)는 p' 즉, 바깥 rainbow에 우선 속한다고 생각을 하고 각 point에 대해 outer_rainbow_count에서 0이라면 즉, 중복된 값이 아니였던 색이라면 p' rainbow에 속한 색의 수가 1증가 했다고 생각한다. 
- 그 후 start와 end 포인터를 움직이며 p rainbow의 구간을 구하면서 결과를 구해준다.
- end 포인터에 대한 연산은 이러하다.
	1) p rainbow에 저장된 (중복되지 않은)색의 수가 k 보다 작거나, p' rainbow에 저장된 (중복되지 않은)색의 수가 k 보다 크다면, p 가 속하는 구간은 늘리고, p'의 범위를 줄여야 하기 때문에 end 포인터에 대해서 연산을 진행한다.
	2) end 포인터에 위치한 점의 색(point_info)를 찾고, 이 점을 p rainbow에는 추가를, p' rainbow에는 제외를 해준다. 
	3) 만약 이 색을 p rainbow에 추가를 했는데 이때 값이 1이라면 즉, 기존에 색이 없었더라면 중복되지 않게끔 저장하는 색의 수를 저장한 num_of_p_rainbow의 값을 증가시킨다.
	4) 만약 이 색을 p' rainbow에서 제외를 했는데 이때 값이 0이라면 즉, 이 점을 지나면 p'에는 해당 색이 하나도 없다는 의미이므로 p' rainbow에서 중복되지 않게끔 저장하는 색의 수를 저장한 num_of_outer_rainbow에서 값을 감소시킨다.
	5) 그 후 end 포인터를 1 증가시켜준다.
- start 포인터에 대한 연산은 이러하다.
	1) p rainbow에 저장된 색의 수가 k 보다 크거나, p' rainbow에 저장된 색의 수가 k 보다 작다면, p가 속하는 구간은 줄이고, p'의 범위는 늘려나가야 하기 때문에 start 포인터에 대해서 연산을 진행한다.
	2) start 포인터에 위치한 점의 색을 찾고 이 점을 p rainbow에서는 제외를, p' rainbow에는 추가를 해준다.
	3) 만약 이 색을 p rainbow에서 제외를 했는데 이때 값이 0이라면 즉, 이 점을 지나면 p에는 해당 색이 하나도 없다는 의미이므로 p rainbow에서 중복되지 않게끔 저장하는 색의 수를 저장한 num_of_p_rainbow의 값을 감소시킨다.
	4) 만약 이 색을 p' rainbow에 추가를 했는데 이때 값이 1이라면 즉, 기존에 색이 없었더라면 중복되지 않게끔 저장하는 색의 수를 저장한 num_of_outer_rainbow 값을 증가시킨다.
	5) 그 후 start 포인터를 1 증가시켜준다.
- 이 과정을 거치고난 후 num_of_p_rainbow와 num_of_outer_rainbow가 k와 같다면 즉, 쌍 rainbow면 구간값(end-start)을 최소값으로 업데이트 해나간다. 
- double_rainbow.py


### 수행시간
- O(n)


---

## Prob2
- 치맥 파티
- 후라이드 치킨 하나늘 먹는 데에 필요한 시간은 a분, 양념 치킨 하나를 먹는 데에 필요한 시간은 b분이다.
- 치킨만을 정확히 t분에 먹을 수 있다면 먹을 수 있는 최대 치킨의 개수를 출력한다.
- 정확히 t분에 맞춰 치킨을 먹을 수 있는 방법이 없다면, 최대한 오래 치킨을 먹고 남은 시간에는 맥주를 마시려고 하는데 이 경우에는 최대한 오래 치킨을 먹을 때 먹을 수 있는 치킨의 개수와 남은 시간을 차례로 출력한다.



### 해결 방법
1. 기본적인 알고리즘은 a와 b치킨 중 먹는 데에 시간이 더 오래걸리는 치킨을 선정해 그 치킨(long_time)을 t 시간내에 가장 많이 먹는 경우(t//long_time)의 수를 구해주고, 이 치킨을 0개부터 최대값까지 먹는 경우의 수를 for문으로 돌며 각각의 경우에 대해 시간이 적게 걸리는 치킨을 얼마나 먹을 수 있는지 구해(t - long_time * longtime_chicken_count) % short_time) 남은 시간(remaining_time)을 기준으로 t 시간에 맞춰 치킨을 먹을 수 있는지, 혹시나 시간이 남으면 최소로 맥주를 마시는 시간이 얼마나 되는지 구해준다.
2. 시간이 오래 걸리는 치킨의 수 + 시간이 적게 걸리는 치킨의 수인 number_of_possible 변수와 두 치킨을 먹고 남은 시간 remaining_time 변수를 이용한다.
3. remaining_time 즉, 치킨을 t 시간내에 정확하게 먹는 조합이 존재한다면 시간을 맞춰 먹을 수 있다는 bool 값 flag를 true로 정하고, 만약 현재까지 저장된 가능한 경우의 수보다 더 많은 수의 치킨을 먹는다면 값을 업데이트 한다. 
4. 만약 remaining_time이 0보다 크고 아직 정확한 t 시간에 치킨을 먹는 경우의 수가 존재하지 않았다면 현재까지 저장된 min_time 즉, 맥주 마시는 시간이 최소인 경우를 계속 업데이트 해나간다.
5. 그 후 flag bool 변수를 보고 true면(정확한 시간에 치킨을 먹는 경우) result_find_zero_time 값을, false면(정확한 시간에 치킨을 먹지 못하고 맥주를 마시는 시간이 최소인 경우) result_not_zero_time과 그때의 맥주를 마시는 최소 시간인 min_times를 출력한다.
- chicken_and_beer.py

### 수행시간
- O(n)


---


