
# week7


## Prob1
- FFT 알고리즘
- [참고 url](https://suhwanc.tistory.com/163)
- [출처](https://www.acmicpc.net/problem/20176)
  
  
  

### 해결 방법
-  기본적으로 바늘이 3개의 선분을 지나가기 위해선 u점과 m점을 지날 때의 기울기와 m점과 l점의 기울기가 같아야 하고, 동시에 이때, m의 위치가 같아야 한다. 
- 즉, u+l = 2 * m 를 만족한다. 
- u+l를 구하기 위해 convolution 합성곱을 이용하는데 더 빠르게 하기 위해 단순히 모든 원소를 곱해주는 것이 아닌 고속 푸리에 변환을 사용한다.
- 그 후 u와 l의 합성곱을 m의 원소와 비교해준다. 
- FFT.py


### 수행시간
- O(nlogn)

## Prob2
- 유사성 검사하기
- n개의 자연수 수열 P와 Q가 있다. 두 수열이 얼마나 유사한지 유사도를 측정하고 싶다.
- 이를 위해, 유사 트리플(triple)을 정의한다.

- `P[i] < P[j] < P[k] 이면서 Q[i] < Q[j] < Q[k]인 인덱스 (i, j, k) 트리플이 존재하면 유사 트리플이라 한다`
  
  
  
### 예시

- P = [2, 5, 9, 5, 1], Q = [1, 4, 5, 3, 2]
   - P[0] < P[1] < P[2], Q[0] < Q[1] < Q[2]
   - P[0] < P[3] < P[2], Q[0] < Q[3] < Q[2]
   - P[4] < P[1] < P[2], Q[4] < Q[1] < Q[2] 
   - P[4] < P[3] < P[2], Q[4] < Q[3] < Q[2]

```python
5
2 5 9 5 1
1 4 5 3 2

```
- 출력

```python
4
```
### 해결 방법
- P 수열과 Q 수열 각각 최대값을 만들고 그 값 + 1 만큼의 새로운 리스트를 만들었다. 이때, P와 Q의 원소는 (값,index) 튜플의 데이터를 가진다 
- P,Q 수열 각각의 원소 값을 접근해 그 값의 index의 set에 해당 값을 계속 update 해나가서 fenwick tree를 P와 Q에 대해서 구현하기 때문에 총 2개(p_fenwicktree,q_fenwicktree)를 구현한다. 
- P 수열과 Q 수열 각각에 대해 특정 값 -> P[i][0]에 대해서 이 값보다 작은 것(p_small)을 구하고 이것을 토대로 특정 값보다 큰 것(p_big)을 구해주고 Q도 마찬가지이다.
- 예를 들어 Pi,Qi가 있다고 할 때, (Pi보다 작으며 동시에 Qi보다 작은 수) x (Pi보다 크며 동시에 Qi보다 큰 수)가 답이 된다. (단, 동시에 크거나 작은 수는 같은 인덱스에 위치한다고 생각)
- triple.py


### 수행시간
- O(n^2) + O(max(P)+max(Q))


### 수정 보완 필요
- Fenwick Tree 사용해보기



